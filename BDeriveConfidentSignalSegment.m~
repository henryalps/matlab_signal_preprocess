function [confidentPos] = BDeriveConfidentSignalSegment(origSig)
%% 求置信区间
[~,~,muci,~] = normfit(origSig);
%% 求全部处在置信区间内的数据段
confidentPos = (origSig >= muci(1)) && (origSig <= muci(2));
end

function [segPos, segLen] = BDevideSegment(confidentPos)
%% BDevideSegment用于计算一个逻辑数组内连续为true的段位置和长度
    index = 1;
    count = 0;
    
    for pos =  2:length(confidentPos)
        if confidentPos(pos)
            if confidentPos(pos - 1)
                count = count + 1;
            else
                index = pos;
                count = 1;
            end
        else
            if confidentPos(pos - 1)
                segPos() = index;
                
            end
        end
        if ~confidentPos(pos - 1) && confidentPos(pos)
            index = pos;
            count = 1;
        elseif confidentPos(pos - 1) && confidentPos(pos)
                count = count + 1;
        elseif confidentPos(pos -1) && ~confidentPos(pos)
        end
        
    end
    
end